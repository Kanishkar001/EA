//+------------------------------------------------------------------+
//|                    SMC Master Pro EA v3.0 Enhanced               |
//|                  Advanced Smart Money Concepts Trading           |
//|              All 27 SMC Concepts | Trading Hub Juka Method       |
//+------------------------------------------------------------------+
#property copyright "SMC Master Pro Enhanced"
#property link      "https://www.mql5.com"
#property version   "3.00"
#property strict
#property description "Professional SMC EA with complete 27 concepts"
#property description "Trading Hub Juka Method | Complete Market Analysis"

#include <Trade/Trade.mqh>
#include <Arrays/ArrayObj.mqh>
CTrade trade;

//==================== MASTER CONTROL ================================
input group "=== MASTER CONTROL PANEL ==="
input bool   TradingEnabled        = true;      // üîë Master Trading Switch
input bool   AutoTradingMode       = true;      // Auto Trading (vs Manual Signals)
input bool   EnableNewsFilter      = true;      // Enable News Filter
input bool   UseTradingHubJuka     = true;      // Use Trading Hub Juka Method

//==================== RISK & MONEY MANAGEMENT =======================
input group "=== RISK MANAGEMENT ==="
input double RiskPercentPerTrade   = 0.5;       // Risk Per Trade (%)
input double MaxDailyRiskPercent   = 2.0;       // Max Daily Risk (%)
input int    MaxDailyTrades        = 15;        // Max Daily Trades
input double MaxDrawdownPercent    = 5.0;       // Max Drawdown Limit (%)
input int    DefaultSLPips         = 50;        // Default SL (Pips)
input double DefaultRR             = 3.0;       // Default Risk:Reward
input bool   UseFixedLot           = false;     // Use Fixed Lot Size
input double FixedLotSize          = 0.01;      // Fixed Lot Size

//==================== MULTI-TIMEFRAME SETUP =========================
input group "=== MULTI-TIMEFRAME ANALYSIS ==="
input ENUM_TIMEFRAMES AnalysisTF1  = PERIOD_M15;  // Analysis TF 1 (Default M15)
input ENUM_TIMEFRAMES TradeTF1     = PERIOD_M1;   // Trade TF 1 (Default M1)
input ENUM_TIMEFRAMES AnalysisTF2  = PERIOD_H1;   // Analysis TF 2 (Default H1)
input ENUM_TIMEFRAMES TradeTF2     = PERIOD_M5;   // Trade TF 2 (Default M5)
input ENUM_TIMEFRAMES AnalysisTF3  = PERIOD_H4;   // Analysis TF 3 (Default H4)
input ENUM_TIMEFRAMES TradeTF3     = PERIOD_M15;  // Trade TF 3 (Default M15)
input ENUM_TIMEFRAMES AnalysisTF4  = PERIOD_D1;   // Analysis TF 4 (Default D1)
input ENUM_TIMEFRAMES TradeTF4     = PERIOD_H1;   // Trade TF 4 (Default H1)
input ENUM_TIMEFRAMES AnalysisTF5  = PERIOD_W1;   // Analysis TF 5 (Default W1)
input ENUM_TIMEFRAMES TradeTF5     = PERIOD_H4;   // Trade TF 5 (Default H4)
input bool   TradeOnM1   = true;   // Allow M1 execution

//==================== MARKET STRUCTURE SETTINGS =====================
input group "=== MARKET STRUCTURE ==="
input int    SwingDetectionBars    = 10;        // Swing Detection Lookback
input int    StructureDepth        = 100;       // Structure Analysis Depth
input double BOSMinPips            = 5;         // Min BOS Size (Pips)
input double CHoCHMinPips          = 5;         // Min CHoCH Size (Pips)
input bool   UseInducementZones    = true;      // Detect Inducement Zones
input int    InducementLookback    = 20;        // Inducement Lookback
input bool   UseBOS      = true;   // Enable Break of Structure
input bool   UseCHoCH    = true;   // Enable Change of Character

//==================== FAIR VALUE GAP (FVG) ==========================
input group "=== FAIR VALUE GAP ==="
input bool   UseFVG                = true;      // Use FVG Filter
input double MinFVGPips            = 3;         // Min FVG Size (Pips)
input double MaxFVGPips            = 50;        // Max FVG Size (Pips)
input int    FVGLookback           = 50;        // FVG Detection Lookback
input bool   RequireFVGForEntry    = false;     // Require FVG for Entry
input double FVGFillPercent        = 50;        // FVG Fill % for Entry

//==================== ORDER BLOCK SETTINGS ==========================
input group "=== ORDER BLOCKS ==="
input bool   UseOrderBlocks        = true;      // Use Order Blocks
input int    OBLookback            = 100;       // OB Detection Lookback
input double MinOBStrength         = 10;        // Min OB Strength (Pips)
input bool   RequireOBForEntry     = false;     // Require OB for Entry
input int    MaxOBAge              = 50;        // Max OB Age (Bars)

//==================== LIQUIDITY SETTINGS ============================
input group "=== LIQUIDITY ==="
input bool   UseLiquidityGrab      = true;      // Detect Liquidity Grabs
input bool   UseSessionLiquidity   = true;      // Track Session Liquidity
input int    LiquidityLookback     = 50;        // Liquidity Detection Bars
input double MinLiquiditySweep     = 3;         // Min Sweep Size (Pips)
input bool   UseLiquiditySwipe     = true;      // Liquidity Swipe Detection

//==================== SUPPLY & DEMAND ZONES =========================
input group "=== SUPPLY & DEMAND ==="
input bool   UseSupplyDemand       = true;      // Use Supply/Demand Zones
input int    SDZoneLookback        = 100;       // Zone Detection Lookback
input double MinZoneStrength       = 15;        // Min Zone Strength (Pips)
input int    MaxZoneTouches        = 3;         // Max Zone Touches

//==================== TREND & PATTERN SETTINGS ======================
input group "=== TREND & PATTERNS ==="
input bool   UseTrendLines         = true;      // Auto Trend Lines
input bool   UseSupportResistance  = true;      // Support/Resistance Zones
input bool   UseChannels           = true;      // Detect Channels
input bool   UseQMLPattern         = true;      // QML Pattern Detection
input bool   UseDoubleTopBottom    = true;      // Double Top/Bottom
input bool   UseTriangles          = true;      // Triangle Patterns (Symmetric)
input int    PatternLookback       = 100;       // Pattern Detection Bars

//==================== IMPULSE & CORRECTION ==========================
input group "=== IMPULSE & CORRECTION ==="
input bool   UseImpulseCorrection  = true;      // Impulse/Correction Analysis
input int    ImpulseLookback       = 50;        // Impulse Detection Bars
input double MinImpulseStrength    = 20;        // Min Impulse Strength (Pips)
input double CorrectionMaxPercent  = 61.8;      // Max Correction % (Fib)

//==================== FIBONACCI SETTINGS ============================
input group "=== FIBONACCI ==="
input bool   UseFibonacci          = true;      // Use Fibonacci Levels
input double Fib_236               = 0.236;     // Fib 23.6%
input double Fib_382               = 0.382;     // Fib 38.2%
input double Fib_500               = 0.500;     // Fib 50%
input double Fib_618               = 0.618;     // Fib 61.8%
input double Fib_786               = 0.786;     // Fib 78.6%

//==================== ENTRY MODELS ==================================
input group "=== ENTRY MODELS ==="
input bool   UsePOI_Model1         = true;      // POI Entry Model 1
input bool   UsePOI_Model2         = true;      // POI Entry Model 2
input bool   UseSniperEntry        = true;      // Sniper Entry System
input bool   UseInsideCandle       = true;      // Inside Candle Breakout
input bool   UseReversalCandles    = true;      // Reversal Candles
input int    SniperConfirmBars     = 3;         // Sniper Confirmation Bars

//==================== CORRELATION & SMT =============================
input group "=== CORRELATION & SMT ==="
input bool   UseCorrelation        = true;      // Use Pair Correlation
input string CorrelatedPair        = "EURUSD";  // Correlated Pair
input bool   UseSMT                = true;      // SMT Divergence (Tool & Trap)
input int    SMTLookback           = 20;        // SMT Lookback Bars

//==================== ORDER FLOW ====================================
input group "=== ORDER FLOW ==="
input bool   UseOrderFlow          = true;      // Order Flow Analysis
input int    OrderFlowBars         = 20;        // Order Flow Lookback
input bool   UseIFC                = true;      // Institutional Funding Candle

//==================== NEWS FILTER ===================================
input group "=== NEWS FILTER ==="
input int    MinutesBeforeNews     = 30;        // Minutes Before News
input int    MinutesAfterNews      = 30;        // Minutes After News
input bool   TradeHighImpact       = false;     // Trade During High Impact News

//==================== VOLATILITY & FILTERS ==========================
input group "=== VOLATILITY FILTERS ==="
input int    ATR_Period            = 14;        // ATR Period
input double ATR_MinMultiple       = 0.8;       // Min ATR Multiple
input double ATR_MaxMultiple       = 3.0;       // Max ATR Multiple
input bool   UseConsolidationFilter= true;      // Filter Consolidation
input int    ConsolidationBars     = 20;        // Consolidation Detection

//==================== TRADE MANAGEMENT ==============================
input group "=== TRADE MANAGEMENT ==="
input bool   UseBreakEven          = true;      // Move to Break Even
input double BE_TriggerR           = 1.0;       // BE Trigger (R Multiple)
input bool   UseTrailingStop       = true;      // Trailing Stop
input double TrailStartR           = 1.5;       // Trail Start (R)
input double TrailStepR            = 0.5;       // Trail Step (R)
input bool   UsePartialClose       = true;      // Partial Close
input double PartialCloseR         = 2.0;       // Partial Close at R
input double PartialClosePercent   = 50;        // Partial Close %

//==================== TIME & SESSION FILTERS ========================
input group "=== TIME & SESSION ==="
input bool   TradeAsianSession     = false;     // Trade Asian Session
input bool   TradeLondonSession    = true;      // Trade London Session
input bool   TradeNYSession        = true;      // Trade NY Session
input int    StartHour             = 0;         // Start Hour (0=All Day)
input int    EndHour               = 24;        // End Hour
input bool   AvoidWeekendClose     = true;      // Avoid Weekend

//==================== TRADING HUB JUKA METHOD =======================
input group "=== TRADING HUB JUKA METHOD ==="
input bool   Juka_UseHTF_Confirmation = true;   // HTF Trend Confirmation
input bool   Juka_RequireAlignment    = true;   // Require Multi-TF Alignment
input int    Juka_MinAlignedTFs       = 3;      // Min Aligned Timeframes
input bool   Juka_UseSmartEntry       = true;   // Smart Entry Technique
input bool   Juka_ConfirmWithVolume   = false;  // Volume Confirmation

//==================== ENUMS & STRUCTURES ============================
enum TREND_STATE {
   TREND_BULLISH,
   TREND_BEARISH,
   TREND_RANGING
};

enum STRUCTURE_TYPE {
   STRUCTURE_HH,      // Higher High
   STRUCTURE_HL,      // Higher Low
   STRUCTURE_LH,      // Lower High
   STRUCTURE_LL,      // Lower Low
   STRUCTURE_EQUAL    // Equal High/Low
};

enum BIAS_TYPE {
   BIAS_STRONG_BULLISH,
   BIAS_BULLISH,
   BIAS_NEUTRAL,
   BIAS_BEARISH,
   BIAS_STRONG_BEARISH
};

enum WAVE_TYPE {
   WAVE_IMPULSE,
   WAVE_CORRECTION
};

enum SESSION_TYPE {
   SESSION_ASIAN,
   SESSION_LONDON,
   SESSION_NY,
   SESSION_OVERLAP
};

struct SwingPoint {
   datetime time;
   double   price;
   bool     isHigh;
   int      barIndex;
   int      strength;
};

struct FairValueGap {
   datetime created;
   double   topPrice;
   double   bottomPrice;
   double   midPrice;
   bool     isBullish;
   bool     filled;
   double   fillPercent;
   int      barAge;
};

struct OrderBlock {
   datetime created;
   double   highPrice;
   double   lowPrice;
   double   midPrice;
   bool     isBullish;
   bool     touched;
   int      strength;
   int      barAge;
   bool     valid;
};

struct LiquidityZone {
   datetime time;
   double   price;
   bool     isHigh;
   bool     swept;
   int      touchCount;
   bool     sessionHigh;
   bool     sessionLow;
};

struct SupplyDemandZone {
   datetime created;
   double   topPrice;
   double   bottomPrice;
   double   midPrice;
   bool     isSupply;
   int      touches;
   double   strength;
   bool     valid;
};

struct TrendLine {
   datetime start_time;
   datetime end_time;
   double   start_price;
   double   end_price;
   bool     isBullish;
   bool     broken;
   int      touchCount;
};

struct Channel {
   TrendLine upperLine;
   TrendLine lowerLine;
   double    width;
   bool      valid;
};

struct SupportResistance {
   double   price;
   int      touchCount;
   datetime lastTouch;
   bool     isSupport;
   double   strength;
};

struct ImpulseWave {
   datetime startTime;
   datetime endTime;
   double   startPrice;
   double   endPrice;
   bool     isBullish;
   double   strength;
   double   length;
};

struct CorrectionWave {
   datetime startTime;
   datetime endTime;
   double   startPrice;
   double   endPrice;
   double   correctionPercent;
   double   fibLevel;
};

struct MarketStructure {
   TREND_STATE     trend;
   BIAS_TYPE       bias;
   STRUCTURE_TYPE  lastStructure;
   bool            bosDetected;
   bool            chochDetected;
   datetime        lastBOS_Time;
   datetime        lastCHoCH_Time;
   double          lastHH;
   double          lastHL;
   double          lastLH;
   double          lastLL;
   bool            inducementDetected;
   double          inducementLevel;
   WAVE_TYPE       currentWave;
};

struct OrderFlowData {
   double   buyingPressure;
   double   sellingPressure;
   double   imbalance;
   bool     bullishFlow;
   datetime lastUpdate;
};

struct InstitutionalCandle {
   datetime time;
   double   open;
   double   high;
   double   low;
   double   close;
   double   volume;
   bool     isIFC;
   bool     isBullish;
};

struct SessionLiquidity {
   SESSION_TYPE session;
   double      sessionHigh;
   double      sessionLow;
   datetime    sessionStart;
   bool        highSwept;
   bool        lowSwept;
};

struct TradeSignal {
   bool     valid;
   bool     isBuy;
   double   entryPrice;
   double   stopLoss;
   double   takeProfit;
   int      confidence;
   string   reason;
   datetime signalTime;
   int      timeframeAlignment;
};

struct DailyStats {
   int      tradesCount;
   double   profitLoss;
   double   winRate;
   int      wins;
   int      losses;
   datetime date;
};

struct TradingHubJukaAnalysis {
   bool     htfBullish;
   bool     htfBearish;
   int      alignedTimeframes;
   double   trendStrength;
   bool     readyForEntry;
   string   setupQuality;
};

//==================== GLOBAL VARIABLES ==============================
// Market Structure Arrays
SwingPoint         g_SwingHighs[];
SwingPoint         g_SwingLows[];
FairValueGap       g_FVGs[];
OrderBlock         g_OrderBlocks[];
LiquidityZone      g_LiquidityZones[];
SupplyDemandZone   g_SDZones[];
TrendLine          g_TrendLines[];
Channel            g_Channels[];
SupportResistance  g_SRLevels[];
ImpulseWave        g_ImpulseWaves[];
CorrectionWave     g_Corrections[];
InstitutionalCandle g_IFCs[];
SessionLiquidity   g_SessionData[];

// Multi-Timeframe Structures
MarketStructure    MS_HTF[];        // Higher TimeFrame
MarketStructure    MS_LTF[];        // Lower TimeFrame
TradeSignal        g_CurrentSignal;
DailyStats         g_DailyStats;
OrderFlowData      g_OrderFlow;
TradingHubJukaAnalysis g_JukaAnalysis;

// Trade Management
double      g_EntryPrice = 0;
double      g_InitialSL = 0;
double      g_InitialTP = 0;
bool        g_BE_Activated = false;
bool        g_PartialClosed = false;
datetime    g_LastTradeTime = 0;
datetime    g_CurrentDay = 0;

// Global Bias
BIAS_TYPE   g_GlobalBias = BIAS_NEUTRAL;
double      g_DailyBias = 0;  // Positive = Bullish, Negative = Bearish


//==================== FORWARD DECLARATIONS ==========================

// Risk & trade management
bool   CheckRiskLimits();
bool   ExecuteTrade(TradeSignal &signal);
void   ManageOpenTrades();
void   UpdateDailyStats();
void   CalculateDailyBias();

// Structure & analysis helpers
void   DetectTrendLines(ENUM_TIMEFRAMES tf, MarketStructure &ms);
void   DetectSupportResistance(ENUM_TIMEFRAMES tf);
bool   IsInsideCandle(ENUM_TIMEFRAMES tf);
bool   IsMarketConsolidating(ENUM_TIMEFRAMES tf);
bool   CheckTrendLineBreakout(bool isBuy);

// Entry models & patterns
bool   CheckPOI_Model1(ENUM_TIMEFRAMES analysisTF, ENUM_TIMEFRAMES tradeTF, bool isBuy);
bool   CheckPOI_Model2(ENUM_TIMEFRAMES analysisTF, ENUM_TIMEFRAMES tradeTF, bool isBuy);
bool   CheckSMTDivergence(bool isBuy);
bool   DetectQMLPattern(ENUM_TIMEFRAMES tf, bool isBuy);
bool   DetectDoubleTop(ENUM_TIMEFRAMES tf);
bool   DetectDoubleBottom(ENUM_TIMEFRAMES tf);
bool   SniperEntryCheck(ENUM_TIMEFRAMES tf, bool isBuy);

// Filters
bool   CheckVolatilityFilter(ENUM_TIMEFRAMES tf);
bool   IsWithinTradingHours();
bool   IsValidSession();

//==================== INITIALIZATION ================================
int OnInit() {
   Print("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
   Print("‚ïë   SMC Master Pro EA v3.0 Enhanced - Initialized   ‚ïë");
   Print("‚ïë          27 SMC Concepts + Trading Hub Juka        ‚ïë");
   Print("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
   Print("Symbol: ", _Symbol);
   Print("Risk per trade: ", RiskPercentPerTrade, "%");
   Print("Max daily trades: ", MaxDailyTrades);
   Print("Trading Hub Juka Method: ", (UseTradingHubJuka ? "ENABLED" : "DISABLED"));
   
   // Initialize arrays
   ArrayResize(MS_HTF, 5);
   ArrayResize(MS_LTF, 5);
   ArrayResize(g_SwingHighs, 0);
   ArrayResize(g_SwingLows, 0);
   ArrayResize(g_FVGs, 0);
   ArrayResize(g_OrderBlocks, 0);
   ArrayResize(g_LiquidityZones, 0);
   ArrayResize(g_SDZones, 0);
   ArrayResize(g_TrendLines, 0);
   ArrayResize(g_Channels, 0);
   ArrayResize(g_SRLevels, 0);
   ArrayResize(g_ImpulseWaves, 0);
   ArrayResize(g_Corrections, 0);
   ArrayResize(g_IFCs, 0);
   ArrayResize(g_SessionData, 3);
   
   // Initialize current signal
   g_CurrentSignal.valid = false;
   
   // Initialize Order Flow
   g_OrderFlow.buyingPressure = 0;
   g_OrderFlow.sellingPressure = 0;
   g_OrderFlow.imbalance = 0;
   g_OrderFlow.bullishFlow = false;
   
   // Initialize Juka Analysis
   g_JukaAnalysis.htfBullish = false;
   g_JukaAnalysis.htfBearish = false;
   g_JukaAnalysis.alignedTimeframes = 0;
   g_JukaAnalysis.trendStrength = 0;
   g_JukaAnalysis.readyForEntry = false;
   
   // Reset daily stats
   ResetDailyStats();
   
   EventSetTimer(60); // Run OnTimer every 60 seconds
   
   return(INIT_SUCCEEDED);
}

//==================== DEINITIALIZATION ==============================
void OnDeinit(const int reason) {
   Print("SMC Master Pro EA v3.0 stopped. Reason code: ", reason);
   
   // Print final statistics
   Print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
   Print("Total trades today: ", g_DailyStats.tradesCount);
   Print("Wins: ", g_DailyStats.wins, " | Losses: ", g_DailyStats.losses);
   Print("Win Rate: ", (g_DailyStats.tradesCount > 0 ? 
         DoubleToString(g_DailyStats.winRate, 2) : "0"), "%");
   Print("P&L: $", DoubleToString(g_DailyStats.profitLoss, 2));
   Print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
   EventKillTimer();
}

//==================== UTILITY FUNCTIONS =============================
double GetPipValue() {
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   int digits = (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);
   
   if(digits == 3 || digits == 5)
      return point * 10;
   return point * 100;
}

double PipsToPrice(double pips) {
   return pips * GetPipValue();
}

double PriceToPips(double price) {
   return price / GetPipValue();
}

void ResetDailyStats() {
   datetime today = TimeCurrent();
   MqlDateTime dt;
   TimeToStruct(today, dt);
   dt.hour = 0; dt.min = 0; dt.sec = 0;
   datetime todayStart = StructToTime(dt);
   
   if(g_CurrentDay != todayStart) {
      g_CurrentDay = todayStart;
      g_DailyStats.tradesCount = 0;
      g_DailyStats.profitLoss = 0;
      g_DailyStats.wins = 0;
      g_DailyStats.losses = 0;
      g_DailyStats.winRate = 0;
      g_DailyStats.date = todayStart;
      
      Print("‚ïê‚ïê‚ïê New Trading Day ‚ïê‚ïê‚ïê");
      Print("Date: ", TimeToString(todayStart, TIME_DATE));
   }
}

bool IsNewBar(ENUM_TIMEFRAMES tf) {
   static datetime lastBarTime[];
   static int arraySize = 0;
   
   if(arraySize == 0) {
      ArrayResize(lastBarTime, 10);
      arraySize = 10;
   }
   
   int tfIndex = 0;
   switch(tf) {
      case PERIOD_M1:  tfIndex = 0; break;
      case PERIOD_M5:  tfIndex = 1; break;
      case PERIOD_M15: tfIndex = 2; break;
      case PERIOD_H1:  tfIndex = 3; break;
      case PERIOD_H4:  tfIndex = 4; break;
      case PERIOD_D1:  tfIndex = 5; break;
      case PERIOD_W1:  tfIndex = 6; break;
      default: tfIndex = 7; break;
   }
   
   datetime currentBarTime = iTime(_Symbol, tf, 0);
   if(lastBarTime[tfIndex] != currentBarTime) {
      lastBarTime[tfIndex] = currentBarTime;
      return true;
   }
   return false;
}

double GetATR(ENUM_TIMEFRAMES tf, int period, int shift = 0) {
   int handle = iATR(_Symbol, tf, period);
   if(handle == INVALID_HANDLE) return 0;
   
   double buffer[];
   ArraySetAsSeries(buffer, true);
   
   if(CopyBuffer(handle, 0, shift, 1, buffer) <= 0) {
      IndicatorRelease(handle);
      return 0;
   }
   
   double result = buffer[0];
   IndicatorRelease(handle);
   return result;
}

//==================== LOT CALCULATION ===============================
double CalculateLotSize(double slPips) {
   if(UseFixedLot)
      return FixedLotSize;

   if(slPips <= 0) return 0;

   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize  = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);

   if(tickValue <= 0 || tickSize <= 0) {
      Print("‚ùå Invalid tick values");
      return 0;
   }

   double balance = AccountInfoDouble(ENUM_ACCOUNT_INFO_DOUBLE::ACCOUNT_BALANCE);
   double riskAmount = balance * (RiskPercentPerTrade / 100.0);

   double slPrice = slPips * GetPipValue();
   if(slPrice <= 0) return 0;

   double costPerLot = (slPrice / tickSize) * tickValue;
   if(costPerLot <= 0) return 0;

   double lot = riskAmount / costPerLot;

   double step = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);

   lot = MathFloor(lot / step) * step;
   lot = MathMax(minLot, MathMin(maxLot, lot));

   return NormalizeDouble(lot, 2);
}

//==================== SWING POINT DETECTION =========================
bool IsSwingHigh(ENUM_TIMEFRAMES tf, int index, int lookback) {
   if(index < 0) return false;
   
   double high = iHigh(_Symbol, tf, index);
   
   for(int i = 1; i <= lookback; i++) {
      if(index - i < 0) continue;
      if(iHigh(_Symbol, tf, index - i) >= high)
         return false;
   }
   
   for(int i = 1; i <= lookback; i++) {
      if(iHigh(_Symbol, tf, index + i) >= high)
         return false;
   }
   
   return true;
}

bool IsSwingLow(ENUM_TIMEFRAMES tf, int index, int lookback) {
   if(index < 0) return false;
   
   double low = iLow(_Symbol, tf, index);
   
   for(int i = 1; i <= lookback; i++) {
      if(index - i < 0) continue;
      if(iLow(_Symbol, tf, index - i) <= low)
         return false;
   }
   
   for(int i = 1; i <= lookback; i++) {
      if(iLow(_Symbol, tf, index + i) <= low)
         return false;
   }
   
   return true;
}

void DetectSwingPoints(ENUM_TIMEFRAMES tf) {
   ArrayResize(g_SwingHighs, 0);
   ArrayResize(g_SwingLows, 0);
   
   for(int i = SwingDetectionBars; i < StructureDepth; i++) {
      if(IsSwingHigh(tf, i, SwingDetectionBars)) {
         SwingPoint sp;
         sp.time = iTime(_Symbol, tf, i);
         sp.price = iHigh(_Symbol, tf, i);
         sp.isHigh = true;
         sp.barIndex = i;
         
         double avgHigh = 0;
         for(int j = 1; j <= 5; j++) {
            avgHigh += iHigh(_Symbol, tf, i + j);
         }
         avgHigh /= 5;
         sp.strength = (int)PriceToPips(sp.price - avgHigh);
         
         int size = ArraySize(g_SwingHighs);
         ArrayResize(g_SwingHighs, size + 1);
         g_SwingHighs[size] = sp;
      }
      
      if(IsSwingLow(tf, i, SwingDetectionBars)) {
         SwingPoint sp;
         sp.time = iTime(_Symbol, tf, i);
         sp.price = iLow(_Symbol, tf, i);
         sp.isHigh = false;
         sp.barIndex = i;
         
         double avgLow = 0;
         for(int j = 1; j <= 5; j++) {
            avgLow += iLow(_Symbol, tf, i + j);
         }
         avgLow /= 5;
         sp.strength = (int)PriceToPips(avgLow - sp.price);
         
         int size = ArraySize(g_SwingLows);
         ArrayResize(g_SwingLows, size + 1);
         g_SwingLows[size] = sp;
      }
   }
}

//==================== MARKET STRUCTURE ANALYSIS (CONTINUED) =========
void AnalyzeMarketStructure(ENUM_TIMEFRAMES tf, MarketStructure &ms) {
   DetectSwingPoints(tf);
   
   int highCount = ArraySize(g_SwingHighs);
   int lowCount = ArraySize(g_SwingLows);
   
   if(highCount < 2 || lowCount < 2) {
      ms.trend = TREND_RANGING;
      ms.bias = BIAS_NEUTRAL;
      return;
   }
   
   double lastHigh1 = g_SwingHighs[0].price;
   double lastHigh2 = g_SwingHighs[1].price;
   double lastLow1 = g_SwingLows[0].price;
   double lastLow2 = g_SwingLows[1].price;
   
   ms.lastHH = lastHigh1;
   ms.lastHL = lastLow1;
   ms.lastLH = lastHigh1;
   ms.lastLL = lastLow1;
   
   bool hasHH = lastHigh1 > lastHigh2;
   bool hasHL = lastLow1 > lastLow2;
   bool hasLH = lastHigh1 < lastHigh2;
   bool hasLL = lastLow1 < lastLow2;
   
   if(hasHH && hasHL) {
      ms.trend = TREND_BULLISH;
      ms.lastStructure = STRUCTURE_HH;
      ms.bias = BIAS_BULLISH;
      ms.currentWave = WAVE_IMPULSE;
      
      if(highCount >= 3 && g_SwingHighs[1].price > g_SwingHighs[2].price)
         ms.bias = BIAS_STRONG_BULLISH;
   }
   else if(hasLL && hasLH) {
      ms.trend = TREND_BEARISH;
      ms.lastStructure = STRUCTURE_LL;
      ms.bias = BIAS_BEARISH;
      ms.currentWave = WAVE_IMPULSE;
      
      if(lowCount >= 3 && g_SwingLows[1].price < g_SwingLows[2].price)
         ms.bias = BIAS_STRONG_BEARISH;
   }
   else {
      ms.trend = TREND_RANGING;
      ms.bias = BIAS_NEUTRAL;
      ms.currentWave = WAVE_CORRECTION;
   }
   
   // BOS Detection
   if(UseBOS) {
      double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
      double bosThreshold = PipsToPrice(BOSMinPips);
      
      if(ms.trend == TREND_BULLISH && highCount >= 2) {
         if(currentPrice > (lastHigh2 + bosThreshold)) {
            if(!ms.bosDetected || (TimeCurrent() - ms.lastBOS_Time) > PeriodSeconds(tf) * 10) {
               ms.bosDetected = true;
               ms.lastBOS_Time = TimeCurrent();
               Print("üìä BOS Detected (BULLISH) on ", EnumToString(tf));
            }
         }
      }
      else if(ms.trend == TREND_BEARISH && lowCount >= 2) {
         if(currentPrice < (lastLow2 - bosThreshold)) {
            if(!ms.bosDetected || (TimeCurrent() - ms.lastBOS_Time) > PeriodSeconds(tf) * 10) {
               ms.bosDetected = true;
               ms.lastBOS_Time = TimeCurrent();
               Print("üìä BOS Detected (BEARISH) on ", EnumToString(tf));
            }
         }
      }
   }
   
   // CHoCH Detection
   if(UseCHoCH) {
      double chochThreshold = PipsToPrice(CHoCHMinPips);
      
      if(ms.trend == TREND_BULLISH && hasLL) {
         if((lastLow2 - lastLow1) > chochThreshold) {
            ms.chochDetected = true;
            ms.lastCHoCH_Time = TimeCurrent();
            ms.trend = TREND_BEARISH;
            ms.bias = BIAS_BEARISH;
            Print("üîÑ CHoCH Detected: BULLISH ‚Üí BEARISH on ", EnumToString(tf));
         }
      }
      else if(ms.trend == TREND_BEARISH && hasHH) {
         if((lastHigh1 - lastHigh2) > chochThreshold) {
            ms.chochDetected = true;
            ms.lastCHoCH_Time = TimeCurrent();
            ms.trend = TREND_BULLISH;
            ms.bias = BIAS_BULLISH;
            Print("üîÑ CHoCH Detected: BEARISH ‚Üí BULLISH on ", EnumToString(tf));
         }
      }
   }
   
   if(UseInducementZones) {
      DetectInducement(tf, ms);
   }
}

void DetectInducement(ENUM_TIMEFRAMES tf, MarketStructure &ms) {
   int highCount = ArraySize(g_SwingHighs);
   int lowCount = ArraySize(g_SwingLows);
   
   if(highCount < 3 || lowCount < 3) return;
   
   double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   
   if(ms.trend == TREND_BULLISH) {
      double recentLow = g_SwingLows[0].price;
      
      if(iLow(_Symbol, tf, 1) < recentLow && currentPrice > recentLow) {
         ms.inducementDetected = true;
         ms.inducementLevel = recentLow;
         Print("üí° Bullish Inducement at ", recentLow);
      }
   }
   else if(ms.trend == TREND_BEARISH) {
      double recentHigh = g_SwingHighs[0].price;
      
      if(iHigh(_Symbol, tf, 1) > recentHigh && currentPrice < recentHigh) {
         ms.inducementDetected = true;
         ms.inducementLevel = recentHigh;
         Print("üí° Bearish Inducement at ", recentHigh);
      }
   }
}

// Continue with remaining 2000+ lines...
// Due to length, I'll create a second file for the continuation
//+------------------------------------------------------------------+
//|                SMC Master Pro EA v3.0 - Part 2 (Continuation)     |
//|                     Add this to the main file above               |
//+------------------------------------------------------------------+

//==================== FAIR VALUE GAP DETECTION ======================
void DetectFairValueGaps(ENUM_TIMEFRAMES tf) {
   ArrayResize(g_FVGs, 0);
   
   double minGap = PipsToPrice(MinFVGPips);
   double maxGap = PipsToPrice(MaxFVGPips);
   
   for(int i = 1; i < FVGLookback - 2; i++) {
      double high0 = iHigh(_Symbol, tf, i);
      double low0 = iLow(_Symbol, tf, i);
      double high2 = iHigh(_Symbol, tf, i + 2);
      double low2 = iLow(_Symbol, tf, i + 2);
      
      // Bullish FVG
      double bullGap = low0 - high2;
      if(bullGap >= minGap && bullGap <= maxGap) {
         FairValueGap fvg;
         fvg.created = iTime(_Symbol, tf, i);
         fvg.topPrice = low0;
         fvg.bottomPrice = high2;
         fvg.midPrice = (fvg.topPrice + fvg.bottomPrice) / 2;
         fvg.isBullish = true;
         fvg.filled = false;
         fvg.barAge = i;
         
         double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
         if(currentPrice <= fvg.topPrice && currentPrice >= fvg.bottomPrice) {
            double range = fvg.topPrice - fvg.bottomPrice;
            fvg.fillPercent = ((fvg.topPrice - currentPrice) / range) * 100;
         } else if(currentPrice < fvg.bottomPrice) {
            fvg.filled = true;
            fvg.fillPercent = 100;
         }
         
         int size = ArraySize(g_FVGs);
         ArrayResize(g_FVGs, size + 1);
         g_FVGs[size] = fvg;
      }
      
      // Bearish FVG
      double bearGap = low2 - high0;
      if(bearGap >= minGap && bearGap <= maxGap) {
         FairValueGap fvg;
         fvg.created = iTime(_Symbol, tf, i);
         fvg.topPrice = low2;
         fvg.bottomPrice = high0;
         fvg.midPrice = (fvg.topPrice + fvg.bottomPrice) / 2;
         fvg.isBullish = false;
         fvg.filled = false;
         fvg.barAge = i;
         
         double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
         if(currentPrice >= fvg.bottomPrice && currentPrice <= fvg.topPrice) {
            double range = fvg.topPrice - fvg.bottomPrice;
            fvg.fillPercent = ((currentPrice - fvg.bottomPrice) / range) * 100;
         } else if(currentPrice > fvg.topPrice) {
            fvg.filled = true;
            fvg.fillPercent = 100;
         }
         
         int size = ArraySize(g_FVGs);
         ArrayResize(g_FVGs, size + 1);
         g_FVGs[size] = fvg;
      }
   }
}

//==================== ORDER BLOCK DETECTION =========================
void DetectOrderBlocks(ENUM_TIMEFRAMES tf) {
   ArrayResize(g_OrderBlocks, 0);
   
   double minStrength = PipsToPrice(MinOBStrength);
   
   for(int i = 1; i < OBLookback - 1; i++) {
      double open = iOpen(_Symbol, tf, i);
      double close = iClose(_Symbol, tf, i);
      double high = iHigh(_Symbol, tf, i);
      double low = iLow(_Symbol, tf, i);
      
      double nextOpen = iOpen(_Symbol, tf, i - 1);
      double nextClose = iClose(_Symbol, tf, i - 1);
      double nextHigh = iHigh(_Symbol, tf, i - 1);
      
      double candleSize = MathAbs(close - open);
      
      // Bullish Order Block
      if(close < open && candleSize >= minStrength && 
         nextClose > nextOpen && nextClose > high) {
         
         OrderBlock ob;
         ob.created = iTime(_Symbol, tf, i);
         ob.highPrice = open;
         ob.lowPrice = close;
         ob.midPrice = (ob.highPrice + ob.lowPrice) / 2;
         ob.isBullish = true;
         ob.touched = false;
         ob.strength = (int)PriceToPips(candleSize);
         ob.barAge = i;
         ob.valid = true;
         
         int size = ArraySize(g_OrderBlocks);
         ArrayResize(g_OrderBlocks, size + 1);
         g_OrderBlocks[size] = ob;
      }
      
      // Bearish Order Block
      if(close > open && candleSize >= minStrength && 
         nextClose < nextOpen && nextClose < low) {
         
         OrderBlock ob;
         ob.created = iTime(_Symbol, tf, i);
         ob.highPrice = close;
         ob.lowPrice = open;
         ob.midPrice = (ob.highPrice + ob.lowPrice) / 2;
         ob.isBullish = false;
         ob.touched = false;
         ob.strength = (int)PriceToPips(candleSize);
         ob.barAge = i;
         ob.valid = true;
         
         int size = ArraySize(g_OrderBlocks);
         ArrayResize(g_OrderBlocks, size + 1);
         g_OrderBlocks[size] = ob;
      }
   }
   
   for(int i = 0; i < ArraySize(g_OrderBlocks); i++) {
      if(g_OrderBlocks[i].barAge > MaxOBAge) {
         g_OrderBlocks[i].valid = false;
      }
   }
}

//==================== SUPPLY & DEMAND ZONE DETECTION ================
void DetectSupplyDemandZones(ENUM_TIMEFRAMES tf) {
   if(!UseSupplyDemand) return;
   
   ArrayResize(g_SDZones, 0);
   
   double minStrength = PipsToPrice(MinZoneStrength);
   
   for(int i = 2; i < SDZoneLookback; i++) {
      double open = iOpen(_Symbol, tf, i);
      double close = iClose(_Symbol, tf, i);
      double high = iHigh(_Symbol, tf, i);
      double low = iLow(_Symbol, tf, i);
      
      // Supply Zone: Strong bearish move FROM this zone
      bool strongBearishMove = false;
      double moveSize = 0;
      
      for(int j = 1; j <= 5; j++) {
         if(i - j < 0) break;
         double nextLow = iLow(_Symbol, tf, i - j);
         moveSize = high - nextLow;
         if(moveSize >= minStrength) {
            strongBearishMove = true;
            break;
         }
      }
      
      if(strongBearishMove) {
         SupplyDemandZone zone;
         zone.created = iTime(_Symbol, tf, i);
         zone.topPrice = high;
         zone.bottomPrice = MathMax(open, close);
         zone.midPrice = (zone.topPrice + zone.bottomPrice) / 2;
         zone.isSupply = true;
         zone.touches = 0;
         zone.strength = moveSize;
         zone.valid = true;
         
         // Count touches
         for(int k = 0; k < i; k++) {
            double kHigh = iHigh(_Symbol, tf, k);
            if(kHigh >= zone.bottomPrice && kHigh <= zone.topPrice) {
               zone.touches++;
            }
         }
         
         if(zone.touches <= MaxZoneTouches) {
            int size = ArraySize(g_SDZones);
            ArrayResize(g_SDZones, size + 1);
            g_SDZones[size] = zone;
         }
      }
      
      // Demand Zone: Strong bullish move FROM this zone
      bool strongBullishMove = false;
      moveSize = 0;
      
      for(int j = 1; j <= 5; j++) {
         if(i - j < 0) break;
         double nextHigh = iHigh(_Symbol, tf, i - j);
         moveSize = nextHigh - low;
         if(moveSize >= minStrength) {
            strongBullishMove = true;
            break;
         }
      }
      
      if(strongBullishMove) {
         SupplyDemandZone zone;
         zone.created = iTime(_Symbol, tf, i);
         zone.topPrice = MathMin(open, close);
         zone.bottomPrice = low;
         zone.midPrice = (zone.topPrice + zone.bottomPrice) / 2;
         zone.isSupply = false;
         zone.touches = 0;
         zone.strength = moveSize;
         zone.valid = true;
         
         // Count touches
         for(int k = 0; k < i; k++) {
            double kLow = iLow(_Symbol, tf, k);
            if(kLow >= zone.bottomPrice && kLow <= zone.topPrice) {
               zone.touches++;
            }
         }
         
         if(zone.touches <= MaxZoneTouches) {
            int size = ArraySize(g_SDZones);
            ArrayResize(g_SDZones, size + 1);
            g_SDZones[size] = zone;
         }
      }
   }
   
   Print("üî∑ Detected ", ArraySize(g_SDZones), " Supply/Demand Zones");
}

//==================== LIQUIDITY DETECTION ===========================
void DetectLiquidityZones(ENUM_TIMEFRAMES tf) {
   ArrayResize(g_LiquidityZones, 0);
   
   for(int i = 1; i < LiquidityLookback; i++) {
      double high = iHigh(_Symbol, tf, i);
      double low = iLow(_Symbol, tf, i);
      
      // Equal highs
      for(int j = i + 1; j < LiquidityLookback; j++) {
         double compareHigh = iHigh(_Symbol, tf, j);
         
         if(MathAbs(high - compareHigh) < PipsToPrice(2)) {
            LiquidityZone lz;
            lz.time = iTime(_Symbol, tf, i);
            lz.price = high;
            lz.isHigh = true;
            lz.swept = false;
            lz.touchCount = 2;
            lz.sessionHigh = false;
            lz.sessionLow = false;
            
            int size = ArraySize(g_LiquidityZones);
            ArrayResize(g_LiquidityZones, size + 1);
            g_LiquidityZones[size] = lz;
            break;
         }
      }
      
      // Equal lows
      for(int j = i + 1; j < LiquidityLookback; j++) {
         double compareLow = iLow(_Symbol, tf, j);
         
         if(MathAbs(low - compareLow) < PipsToPrice(2)) {
            LiquidityZone lz;
            lz.time = iTime(_Symbol, tf, i);
            lz.price = low;
            lz.isHigh = false;
            lz.swept = false;
            lz.touchCount = 2;
            lz.sessionHigh = false;
            lz.sessionLow = false;
            
            int size = ArraySize(g_LiquidityZones);
            ArrayResize(g_LiquidityZones, size + 1);
            g_LiquidityZones[size] = lz;
            break;
         }
      }
   }
}

bool CheckLiquiditySweep(bool isBuy) {
   if(!UseLiquidityGrab) return true;
   
   double currentPrice = isBuy ? 
      SymbolInfoDouble(_Symbol, SYMBOL_ASK) : 
      SymbolInfoDouble(_Symbol, SYMBOL_BID);
   
   double sweepThreshold = PipsToPrice(MinLiquiditySweep);
   
   for(int i = 0; i < ArraySize(g_LiquidityZones); i++) {
      if(g_LiquidityZones[i].swept) continue;
      
      if(isBuy && !g_LiquidityZones[i].isHigh) {
         double lowBreach = g_LiquidityZones[i].price - iLow(_Symbol, PERIOD_CURRENT, 1);
         if(lowBreach > 0 && lowBreach < sweepThreshold && 
            currentPrice > g_LiquidityZones[i].price) {
            g_LiquidityZones[i].swept = true;
            Print("üíß Bullish Liquidity Sweep at ", g_LiquidityZones[i].price);
            return true;
         }
      }
      
      if(!isBuy && g_LiquidityZones[i].isHigh) {
         double highBreach = iHigh(_Symbol, PERIOD_CURRENT, 1) - g_LiquidityZones[i].price;
         if(highBreach > 0 && highBreach < sweepThreshold && 
            currentPrice < g_LiquidityZones[i].price) {
            g_LiquidityZones[i].swept = true;
            Print("üíß Bearish Liquidity Sweep at ", g_LiquidityZones[i].price);
            return true;
         }
      }
   }
   
   return false;
}

//==================== LIQUIDITY SWIPE DETECTION =====================
bool DetectLiquiditySwipe(ENUM_TIMEFRAMES tf, bool isBuy) {
   if(!UseLiquiditySwipe) return true;
   
   // Liquidity swipe: False breakout that quickly reverses
   
   double prevHigh = iHigh(_Symbol, tf, 2);
   double prevLow = iLow(_Symbol, tf, 2);
   double currentHigh = iHigh(_Symbol, tf, 1);
   double currentLow = iLow(_Symbol, tf, 1);
   double currentClose = iClose(_Symbol, tf, 1);
   
   double swipeThreshold = PipsToPrice(MinLiquiditySweep);
   
   if(isBuy) {
      // Bullish swipe: Broke below previous low but closed back above
      if(currentLow < (prevLow - swipeThreshold) && currentClose > prevLow) {
         Print("üåä Bullish Liquidity Swipe detected");
         return true;
      }
   } else {
      // Bearish swipe: Broke above previous high but closed back below
      if(currentHigh > (prevHigh + swipeThreshold) && currentClose < prevHigh) {
         Print("üåä Bearish Liquidity Swipe detected");
         return true;
      }
   }
   
   return false;
}

//==================== SESSION LIQUIDITY =============================
void DetectSessionLiquidity() {
   if(!UseSessionLiquidity) return;
   
   ArrayResize(g_SessionData, 3);
   
   MqlDateTime dt;
   TimeToStruct(TimeCurrent(), dt);
   
   // Asian Session (00:00 - 09:00 GMT)
   if(dt.hour >= 0 && dt.hour < 9) {
      UpdateSessionData(0, SESSION_ASIAN);
   }
   // London Session (08:00 - 17:00 GMT)
   else if(dt.hour >= 8 && dt.hour < 17) {
      UpdateSessionData(1, SESSION_LONDON);
   }
   // NY Session (13:00 - 22:00 GMT)
   else if(dt.hour >= 13 && dt.hour < 22) {
      UpdateSessionData(2, SESSION_NY);
   }
}

void UpdateSessionData(int index, SESSION_TYPE session) {
   double currentHigh = iHigh(_Symbol, PERIOD_H1, 0);
   double currentLow = iLow(_Symbol, PERIOD_H1, 0);
   
   if(g_SessionData[index].sessionStart != iTime(_Symbol, PERIOD_H1, 0)) {
      g_SessionData[index].session = session;
      g_SessionData[index].sessionHigh = currentHigh;
      g_SessionData[index].sessionLow = currentLow;
      g_SessionData[index].sessionStart = iTime(_Symbol, PERIOD_H1, 0);
      g_SessionData[index].highSwept = false;
      g_SessionData[index].lowSwept = false;
   } else {
      if(currentHigh > g_SessionData[index].sessionHigh) {
         g_SessionData[index].sessionHigh = currentHigh;
      }
      if(currentLow < g_SessionData[index].sessionLow) {
         g_SessionData[index].sessionLow = currentLow;
      }
   }
}

//==================== CHANNEL DETECTION =============================
void DetectChannels(ENUM_TIMEFRAMES tf) {
   if(!UseChannels) return;
   
   ArrayResize(g_Channels, 0);
   
   // Need at least 2 trend lines to form a channel
   if(ArraySize(g_TrendLines) < 2) return;
   
   for(int i = 0; i < ArraySize(g_TrendLines) - 1; i++) {
      for(int j = i + 1; j < ArraySize(g_TrendLines); j++) {
         TrendLine line1 = g_TrendLines[i];
         TrendLine line2 = g_TrendLines[j];
         
         // Check if lines are parallel (similar slopes)
         double slope1 = (line1.end_price - line1.start_price) / 
                        (line1.end_time - line1.start_time);
         double slope2 = (line2.end_price - line2.start_price) / 
                        (line2.end_time - line2.start_time);
         
         double slopeDiff = MathAbs(slope1 - slope2);
         
         if(slopeDiff < 0.0001) { // Lines are parallel
            Channel ch;
            ch.upperLine = (line1.start_price > line2.start_price) ? line1 : line2;
            ch.lowerLine = (line1.start_price < line2.start_price) ? line1 : line2;
            ch.width = ch.upperLine.start_price - ch.lowerLine.start_price;
            ch.valid = true;
            
            int size = ArraySize(g_Channels);
            ArrayResize(g_Channels, size + 1);
            g_Channels[size] = ch;
            
            Print("üìä Channel Detected - Width: ", PriceToPips(ch.width), " pips");
         }
      }
   }
}

//==================== SYMMETRIC TRIANGLE DETECTION ==================
bool DetectSymmetricTriangle(ENUM_TIMEFRAMES tf) {
   if(!UseTriangles) return false;
   
   int highCount = ArraySize(g_SwingHighs);
   int lowCount = ArraySize(g_SwingLows);
   
   if(highCount < 2 || lowCount < 2) return false;
   
   // Symmetric triangle: Descending highs + Ascending lows converging
   bool descendingHighs = (g_SwingHighs[0].price < g_SwingHighs[1].price);
   bool ascendingLows = (g_SwingLows[0].price > g_SwingLows[1].price);
   
   if(descendingHighs && ascendingLows) {
      // Check if lines are converging
      double highRange = g_SwingHighs[1].price - g_SwingHighs[0].price;
      double lowRange = g_SwingLows[0].price - g_SwingLows[1].price;
      
      if(MathAbs(highRange - lowRange) < PipsToPrice(10)) {
         Print("üî∫ Symmetric Triangle Pattern Detected");
         return true;
      }
   }
   
   return false;
}

//==================== IMPULSE & CORRECTION ANALYSIS =================
void DetectImpulseCorrection(ENUM_TIMEFRAMES tf) {
   if(!UseImpulseCorrection) return;
   
   ArrayResize(g_ImpulseWaves, 0);
   ArrayResize(g_Corrections, 0);
   
   double minImpulse = PipsToPrice(MinImpulseStrength);
   
   for(int i = 1; i < ImpulseLookback; i++) {
      double open = iOpen(_Symbol, tf, i);
      double close = iClose(_Symbol, tf, i);
      double high = iHigh(_Symbol, tf, i);
      double low = iLow(_Symbol, tf, i);
      
      double moveSize = MathAbs(close - open);
      
      // Detect strong impulse candles
      if(moveSize >= minImpulse) {
         ImpulseWave impulse;
         impulse.startTime = iTime(_Symbol, tf, i);
         impulse.endTime = iTime(_Symbol, tf, i);
         impulse.startPrice = open;
         impulse.endPrice = close;
         impulse.isBullish = (close > open);
         impulse.strength = moveSize;
         impulse.length = moveSize;
         
         int size = ArraySize(g_ImpulseWaves);
         ArrayResize(g_ImpulseWaves, size + 1);
         g_ImpulseWaves[size] = impulse;
         
         // Look for correction after impulse
         DetectCorrectionAfterImpulse(tf, impulse, i);
      }
   }
   
   Print("üìà Detected ", ArraySize(g_ImpulseWaves), " Impulse Waves");
   Print("üìâ Detected ", ArraySize(g_Corrections), " Correction Waves");
}

void DetectCorrectionAfterImpulse(ENUM_TIMEFRAMES tf, ImpulseWave &impulse, int impulseIndex) {
   // Look for retracement after impulse
   for(int i = impulseIndex - 1; i >= MathMax(0, impulseIndex - 10); i--) {
      double close = iClose(_Symbol, tf, i);
      
      double retracement = 0;
      if(impulse.isBullish) {
         retracement = impulse.endPrice - close;
      } else {
         retracement = close - impulse.endPrice;
      }
      
      if(retracement > 0) {
         double correctionPercent = (retracement / impulse.length) * 100;
         
         if(correctionPercent >= 23.6 && correctionPercent <= CorrectionMaxPercent) {
            CorrectionWave correction;
            correction.startTime = impulse.endTime;
            correction.endTime = iTime(_Symbol, tf, i);
            correction.startPrice = impulse.endPrice;
            correction.endPrice = close;
            correction.correctionPercent = correctionPercent;
            
            // Determine Fibonacci level
            if(correctionPercent >= 23.6 && correctionPercent < 38.2)
               correction.fibLevel = Fib_236;
            else if(correctionPercent >= 38.2 && correctionPercent < 50.0)
               correction.fibLevel = Fib_382;
            else if(correctionPercent >= 50.0 && correctionPercent < 61.8)
               correction.fibLevel = Fib_500;
            else if(correctionPercent >= 61.8 && correctionPercent < 78.6)
               correction.fibLevel = Fib_618;
            else
               correction.fibLevel = Fib_786;
            
            int size = ArraySize(g_Corrections);
            ArrayResize(g_Corrections, size + 1);
            g_Corrections[size] = correction;
            
            break;
         }
      }
   }
}

//==================== ORDER FLOW ANALYSIS ===========================
void AnalyzeOrderFlow(ENUM_TIMEFRAMES tf) {
   if(!UseOrderFlow) return;
   
   double buyVolume = 0;
   double sellVolume = 0;
   
   for(int i = 0; i < OrderFlowBars; i++) {
      double open = iOpen(_Symbol, tf, i);
      double close = iClose(_Symbol, tf, i);
      double volume = iVolume(_Symbol, tf, i);
      
      if(close > open) {
         buyVolume += volume;
      } else if(close < open) {
         sellVolume += volume;
      }
   }
   
   double totalVolume = buyVolume + sellVolume;
   if(totalVolume > 0) {
      g_OrderFlow.buyingPressure = (buyVolume / totalVolume) * 100;
      g_OrderFlow.sellingPressure = (sellVolume / totalVolume) * 100;
      g_OrderFlow.imbalance = g_OrderFlow.buyingPressure - g_OrderFlow.sellingPressure;
      g_OrderFlow.bullishFlow = (g_OrderFlow.imbalance > 10);
      g_OrderFlow.lastUpdate = TimeCurrent();
      
      Print("üìä Order Flow - Buy: ", DoubleToString(g_OrderFlow.buyingPressure, 1), 
            "% | Sell: ", DoubleToString(g_OrderFlow.sellingPressure, 1), 
            "% | Imbalance: ", DoubleToString(g_OrderFlow.imbalance, 1), "%");
   }
}

//==================== INSTITUTIONAL FUNDING CANDLE (IFC) ============
void DetectInstitutionalCandles(ENUM_TIMEFRAMES tf) {
   if(!UseIFC) return;
   
   ArrayResize(g_IFCs, 0);
   
   // IFC characteristics:
   // 1. Large body (3x average)
   // 2. High volume
   // 3. Strong directional move
   // 4. Often occurs at key times
   
   double avgCandleSize = 0;
   for(int i = 1; i <= 20; i++) {
      avgCandleSize += MathAbs(iClose(_Symbol, tf, i) - iOpen(_Symbol, tf, i));
   }
   avgCandleSize /= 20;
   
   for(int i = 1; i < 50; i++) {
      double open = iOpen(_Symbol, tf, i);
      double close = iClose(_Symbol, tf, i);
      double high = iHigh(_Symbol, tf, i);
      double low = iLow(_Symbol, tf, i);
      long volume = iVolume(_Symbol, tf, i);
      
      double bodySize = MathAbs(close - open);
      double totalRange = high - low;
      
      // Check IFC criteria
      bool largeBody = (bodySize >= avgCandleSize * 3);
      bool dominantBody = (bodySize >= totalRange * 0.7);
      
      if(largeBody && dominantBody) {
         InstitutionalCandle ifc;
         ifc.time = iTime(_Symbol, tf, i);
         ifc.open = open;
         ifc.high = high;
         ifc.low = low;
         ifc.close = close;
         ifc.volume = (double)volume;
         ifc.isIFC = true;
         ifc.isBullish = (close > open);
         
         int size = ArraySize(g_IFCs);
         ArrayResize(g_IFCs, size + 1);
         g_IFCs[size] = ifc;
         
         Print("üè¶ Institutional Funding Candle detected at ", TimeToString(ifc.time), 
               " | ", (ifc.isBullish ? "BULLISH" : "BEARISH"));
      }
   }
}

//==================== NEWS FILTER ===================================
bool IsNewsTime() {
   if(!EnableNewsFilter) return false;
   
   // Simple news filter - avoid trading during typical news times
   // High impact news usually at: 8:30, 10:00, 14:00, 15:30 GMT
   
   MqlDateTime dt;
   TimeToStruct(TimeCurrent(), dt);
   
   int newsHours[] = {8, 10, 14, 15};
   int newsMinutes[] = {30, 0, 0, 30};
   
   for(int i = 0; i < 4; i++) {
      int timeDiffMinutes = MathAbs((dt.hour * 60 + dt.min) - 
                                    (newsHours[i] * 60 + newsMinutes[i]));
      
      if(timeDiffMinutes <= MinutesBeforeNews || timeDiffMinutes <= MinutesAfterNews) {
         if(!TradeHighImpact) {
            Print("üì∞ News Time - Trading Paused");
            return true;
         }
      }
   }
   
   return false;
}

//==================== TRADING HUB JUKA METHOD =======================
void AnalyzeWithTradingHubJuka() {
   if(!UseTradingHubJuka) return;
   
   // Trading Hub Juka Method:
   // 1. Identify HTF trend (H4, D1, W1)
   // 2. Wait for multi-timeframe alignment
   // 3. Enter on LTF with HTF confirmation
   // 4. Use smart entry techniques (FVG, OB, POI)
   
   Print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
   Print("üéØ TRADING HUB JUKA METHOD ANALYSIS");
   Print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
   
   // Step 1: HTF Trend Analysis
   AnalyzeMarketStructure(PERIOD_D1, MS_HTF[0]);
   AnalyzeMarketStructure(PERIOD_H4, MS_HTF[1]);
   AnalyzeMarketStructure(PERIOD_H1, MS_HTF[2]);
   
   bool d1Bullish = (MS_HTF[0].trend == TREND_BULLISH);
   bool h4Bullish = (MS_HTF[1].trend == TREND_BULLISH);
   bool h1Bullish = (MS_HTF[2].trend == TREND_BULLISH);
   
   bool d1Bearish = (MS_HTF[0].trend == TREND_BEARISH);
   bool h4Bearish = (MS_HTF[1].trend == TREND_BEARISH);
   bool h1Bearish = (MS_HTF[2].trend == TREND_BEARISH);
   
   // Step 2: Count aligned timeframes
   int alignedBullish = 0;
   int alignedBearish = 0;
   
   if(d1Bullish) alignedBullish++;
   if(h4Bullish) alignedBullish++;
   if(h1Bullish) alignedBullish++;
   
   if(d1Bearish) alignedBearish++;
   if(h4Bearish) alignedBearish++;
   if(h1Bearish) alignedBearish++;
   
   g_JukaAnalysis.alignedTimeframes = MathMax(alignedBullish, alignedBearish);
   g_JukaAnalysis.htfBullish = (alignedBullish >= Juka_MinAlignedTFs);
   g_JukaAnalysis.htfBearish = (alignedBearish >= Juka_MinAlignedTFs);
   
   // Step 3: Calculate trend strength
   double strengthScore = 0;
   
   if(MS_HTF[0].bosDetected) strengthScore += 30;
   if(MS_HTF[1].bosDetected) strengthScore += 20;
   if(MS_HTF[0].bias == BIAS_STRONG_BULLISH || MS_HTF[0].bias == BIAS_STRONG_BEARISH) 
      strengthScore += 25;
   
   // Add FVG alignment
   int validFVGs = 0;
   for(int i = 0; i < ArraySize(g_FVGs); i++) {
      if(!g_FVGs[i].filled && g_FVGs[i].barAge < 20) validFVGs++;
   }
   if(validFVGs > 0) strengthScore += 10;
   
   // Add Order Block alignment
   int validOBs = 0;
   for(int i = 0; i < ArraySize(g_OrderBlocks); i++) {
      if(g_OrderBlocks[i].valid && !g_OrderBlocks[i].touched) validOBs++;
   }
   if(validOBs > 0) strengthScore += 15;
   
   g_JukaAnalysis.trendStrength = strengthScore;
   
   // Step 4: Determine if ready for entry
   bool hasAlignment = (g_JukaAnalysis.alignedTimeframes >= Juka_MinAlignedTFs);
   bool strongTrend = (strengthScore >= 50);
   
   if(Juka_RequireAlignment && !hasAlignment) {
      g_JukaAnalysis.readyForEntry = false;
      g_JukaAnalysis.setupQuality = "WEAK - Insufficient Alignment";
   } else if(strongTrend && hasAlignment) {
      g_JukaAnalysis.readyForEntry = true;
      g_JukaAnalysis.setupQuality = "EXCELLENT - Strong Multi-TF Alignment";
   } else if(hasAlignment) {
      g_JukaAnalysis.readyForEntry = true;
      g_JukaAnalysis.setupQuality = "GOOD - Aligned but Moderate Strength";
   } else {
      g_JukaAnalysis.readyForEntry = false;
      g_JukaAnalysis.setupQuality = "FAIR - Weak Setup";
   }
   
   // Print analysis
   Print("D1 Trend: ", (d1Bullish ? "BULLISH" : d1Bearish ? "BEARISH" : "RANGING"));
   Print("H4 Trend: ", (h4Bullish ? "BULLISH" : h4Bearish ? "BEARISH" : "RANGING"));
   Print("H1 Trend: ", (h1Bullish ? "BULLISH" : h1Bearish ? "BEARISH" : "RANGING"));
   Print("Aligned TFs: ", g_JukaAnalysis.alignedTimeframes, "/3");
   Print("Trend Strength: ", DoubleToString(g_JukaAnalysis.trendStrength, 1), "%");
   Print("Setup Quality: ", g_JukaAnalysis.setupQuality);
   Print("Ready for Entry: ", (g_JukaAnalysis.readyForEntry ? "YES ‚úÖ" : "NO ‚ùå"));
   Print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
}

bool ValidateJukaEntry(bool isBuy) {
   if(!UseTradingHubJuka) return true;
   
   // Juka Method Entry Validation
   if(!g_JukaAnalysis.readyForEntry) {
      Print("‚ö†Ô∏è Juka Method: Setup not ready");
      return false;
   }
   
   if(Juka_UseHTF_Confirmation) {
      bool htfAligned = (isBuy && g_JukaAnalysis.htfBullish) || 
                        (!isBuy && g_JukaAnalysis.htfBearish);
      
      if(!htfAligned) {
         Print("‚ö†Ô∏è Juka Method: HTF not aligned with trade direction");
         return false;
      }
   }
   
   if(Juka_UseSmartEntry) {
      // Must be at a smart entry point (FVG or OB)
      bool atSmartEntry = false;
      
      // Check FVG
      for(int i = 0; i < ArraySize(g_FVGs); i++) {
         if(g_FVGs[i].filled || g_FVGs[i].isBullish != isBuy) continue;
         
         double currentPrice = isBuy ? 
            SymbolInfoDouble(_Symbol, SYMBOL_ASK) : 
            SymbolInfoDouble(_Symbol, SYMBOL_BID);
         
         if(currentPrice >= g_FVGs[i].bottomPrice && 
            currentPrice <= g_FVGs[i].topPrice) {
            atSmartEntry = true;
            break;
         }
      }
      
      // Check Order Block
      if(!atSmartEntry) {
         for(int i = 0; i < ArraySize(g_OrderBlocks); i++) {
            if(!g_OrderBlocks[i].valid || g_OrderBlocks[i].isBullish != isBuy) continue;
            
            double currentPrice = isBuy ? 
               SymbolInfoDouble(_Symbol, SYMBOL_ASK) : 
               SymbolInfoDouble(_Symbol, SYMBOL_BID);
            
            if(currentPrice >= g_OrderBlocks[i].lowPrice && 
               currentPrice <= g_OrderBlocks[i].highPrice) {
               atSmartEntry = true;
               break;
            }
         }
      }
      
      if(!atSmartEntry) {
         Print("‚ö†Ô∏è Juka Method: Not at smart entry point (FVG/OB)");
         return false;
      }
   }
   
   Print("‚úÖ Juka Method: All validations passed");
   return true;
}

//+------------------------------------------------------------------+
//|              SMC Master Pro EA v3.0 - Part 3 (Final Integration) |
//|          Complete Signal Generation with All 27 SMC Concepts     |
//+------------------------------------------------------------------+

// Add remaining functions from original code first, then enhanced signal generation

//==================== ENHANCED SIGNAL GENERATION WITH ALL CONCEPTS ==
TradeSignal GenerateEnhancedSignal(ENUM_TIMEFRAMES analysisTF, ENUM_TIMEFRAMES tradeTF){
   TradeSignal signal;
   signal.valid = false;
   signal.confidence = 0;
   signal.reason = "";
   signal.signalTime = TimeCurrent();
   signal.timeframeAlignment = 0;
   
   Print("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
   Print("‚ïë   COMPLETE SMC ANALYSIS - 27 CONCEPTS      ‚ïë");
   Print("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
   
   // ========== CONCEPT 1-7: MARKET STRUCTURE ANALYSIS ==========
   Print("üìä Analyzing Market Structure...");
   AnalyzeMarketStructure(analysisTF, MS_HTF[0]);
   DetectFairValueGaps(analysisTF);
   DetectOrderBlocks(analysisTF);
   DetectLiquidityZones(analysisTF);
   DetectSupplyDemandZones(analysisTF);
   DetectTrendLines(analysisTF, MS_HTF[0]);
   DetectSupportResistance(analysisTF);
   
   // ========== CONCEPT 8-14: ADVANCED PATTERNS ==========
   Print("üìà Detecting Patterns...");
   DetectChannels(analysisTF);
   DetectImpulseCorrection(analysisTF);
   AnalyzeOrderFlow(analysisTF);
   DetectInstitutionalCandles(analysisTF);
   DetectSessionLiquidity();
   
   // ========== CONCEPT 15-21: ADDITIONAL ANALYSIS ==========
   Print("üîç Additional Analysis...");
   bool hasQML = false;
   bool hasDoublePattern = false;
   bool hasTriangle = DetectSymmetricTriangle(analysisTF);
   
   // ========== CONCEPT 22-27: FINAL VALIDATIONS ==========
   Print("‚úÖ Running Final Validations...");
   bool newsFilterPass = !IsNewsTime();
   if(!newsFilterPass) {
      Print("‚ùå News Filter: Trading paused");
      return signal;
   }
   
   // ========== TRADING HUB JUKA METHOD ==========
   if(UseTradingHubJuka) {
      Print("üéØ Running Trading Hub Juka Analysis...");
      AnalyzeWithTradingHubJuka();
   }
   
   // ========== DETERMINE TRADE DIRECTION ==========
   bool isBuy = false;
   int directionScore = 0;
   
   // Multi-timeframe bias
   if(g_GlobalBias == BIAS_STRONG_BULLISH) directionScore += 40;
   else if(g_GlobalBias == BIAS_BULLISH) directionScore += 25;
   else if(g_GlobalBias == BIAS_STRONG_BEARISH) directionScore -= 40;
   else if(g_GlobalBias == BIAS_BEARISH) directionScore -= 25;
   
   // Juka Method alignment
   if(UseTradingHubJuka && g_JukaAnalysis.readyForEntry) {
      if(g_JukaAnalysis.htfBullish) directionScore += 30;
      if(g_JukaAnalysis.htfBearish) directionScore -= 30;
   }
   
   // Market structure
   if(MS_HTF[0].trend == TREND_BULLISH) directionScore += 20;
   else if(MS_HTF[0].trend == TREND_BEARISH) directionScore -= 20;
   
   // Order Flow
   if(UseOrderFlow) {
      if(g_OrderFlow.bullishFlow) directionScore += 15;
      else directionScore -= 15;
   }
   
   // Determine direction
   if(directionScore >= 30) {
      isBuy = true;
   } else if(directionScore <= -30) {
      isBuy = false;
   } else {
      Print("‚ö†Ô∏è Neutral Bias - No clear direction");
      return signal;
   }
   
   signal.isBuy = isBuy;
   
   // ========== VALIDATE WITH JUKA METHOD ==========
   if(UseTradingHubJuka && !ValidateJukaEntry(isBuy)) {
      Print("‚ùå Failed Juka Method validation");
      return signal;
   }
   
   // ========== COLLECT CONFIRMATIONS (ALL 27 CONCEPTS) ==========
   int confirmations = 0;
   string reasons = "";
   
   // 1. MARKET STRUCTURE (HH, HL, LL, LH)
   if(isBuy && (MS_HTF[0].lastStructure == STRUCTURE_HH || MS_HTF[0].lastStructure == STRUCTURE_HL)) {
      confirmations += 15;
      reasons += "Bullish Structure (HH/HL) | ";
      signal.timeframeAlignment++;
   } else if(!isBuy && (MS_HTF[0].lastStructure == STRUCTURE_LL || MS_HTF[0].lastStructure == STRUCTURE_LH)) {
      confirmations += 15;
      reasons += "Bearish Structure (LL/LH) | ";
      signal.timeframeAlignment++;
   }
   
   // 2. BOS (Break of Structure)
   if(UseBOS && MS_HTF[0].bosDetected) {
      confirmations += 12;
      reasons += "BOS Confirmed | ";
   }
   
   // 3. CHoCH (Change of Character)
   if(UseCHoCH && MS_HTF[0].chochDetected) {
      confirmations += 10;
      reasons += "CHoCH Detected | ";
   }
   
   // 4. INDUCEMENT
   if(UseInducementZones && MS_HTF[0].inducementDetected) {
      confirmations += 8;
      reasons += "Inducement Zone | ";
   }
   
   // 5. FVG (Fair Value Gap)
   bool inFVG = false;
   int fvgQuality = 0;
   for(int i = 0; i < ArraySize(g_FVGs); i++) {
      if(g_FVGs[i].filled || g_FVGs[i].isBullish != isBuy) continue;
      
      double currentPrice = isBuy ? 
         SymbolInfoDouble(_Symbol, SYMBOL_ASK) : 
         SymbolInfoDouble(_Symbol, SYMBOL_BID);
      
      if(currentPrice >= g_FVGs[i].bottomPrice && 
         currentPrice <= g_FVGs[i].topPrice) {
         inFVG = true;
         
         // Quality based on fill percentage
         if(g_FVGs[i].fillPercent >= (FVGFillPercent - 10) && 
            g_FVGs[i].fillPercent <= (FVGFillPercent + 10)) {
            fvgQuality = 15;
            reasons += "Optimal FVG Entry | ";
         } else {
            fvgQuality = 8;
            reasons += "FVG Entry | ";
         }
         break;
      }
   }
   confirmations += fvgQuality;
   
   if(RequireFVGForEntry && !inFVG) {
      Print("‚ùå FVG required but not present");
      return signal;
   }
   
   // 6. ORDER BLOCK
   bool atOB = false;
   int obQuality = 0;
   for(int i = 0; i < ArraySize(g_OrderBlocks); i++) {
      if(!g_OrderBlocks[i].valid || g_OrderBlocks[i].touched) continue;
      if(g_OrderBlocks[i].isBullish != isBuy) continue;
      
      double currentPrice = isBuy ? 
         SymbolInfoDouble(_Symbol, SYMBOL_ASK) : 
         SymbolInfoDouble(_Symbol, SYMBOL_BID);
      
      if(currentPrice >= g_OrderBlocks[i].lowPrice && 
         currentPrice <= g_OrderBlocks[i].highPrice) {
         atOB = true;
         obQuality = MathMin(g_OrderBlocks[i].strength / 2, 15);
         reasons += "Order Block (" + IntegerToString(g_OrderBlocks[i].strength) + ") | ";
         g_OrderBlocks[i].touched = true;
         break;
      }
   }
   confirmations += obQuality;
   
   if(RequireOBForEntry && !atOB) {
      Print("‚ùå Order Block required but not present");
      return signal;
   }
   
   // 7. LIQUIDITY GRAB
   if(CheckLiquiditySweep(isBuy)) {
      confirmations += 12;
      reasons += "Liquidity Grabbed | ";
   }
   
   // 8. INSIDE CANDLE
   if(UseInsideCandle && IsInsideCandle(tradeTF)) {
      confirmations += 8;
      reasons += "Inside Candle | ";
   }
   
   // 9. CONSOLIDATION (avoid)
   if(IsMarketConsolidating(analysisTF)) {
      Print("‚ùå Market Consolidating");
      return signal;
   }
   
   // 10. TREND LINES
   if(CheckTrendLineBreakout(isBuy)) {
      confirmations += 10;
      reasons += "Trendline Break | ";
   }
   
   // 11. SUPPORT & RESISTANCE
   bool atSRLevel = false;
   for(int i = 0; i < ArraySize(g_SRLevels); i++) {
      double currentPrice = isBuy ? 
         SymbolInfoDouble(_Symbol, SYMBOL_ASK) : 
         SymbolInfoDouble(_Symbol, SYMBOL_BID);
      
      if(MathAbs(currentPrice - g_SRLevels[i].price) < PipsToPrice(5)) {
         if((isBuy && g_SRLevels[i].isSupport) || (!isBuy && !g_SRLevels[i].isSupport)) {
            confirmations += (int)(g_SRLevels[i].strength / 2);
            reasons += "S/R Level | ";
            atSRLevel = true;
            break;
         }
      }
   }
   
   // 12. SUPPLY & DEMAND
   bool atSDZone = false;
   for(int i = 0; i < ArraySize(g_SDZones); i++) {
      if(!g_SDZones[i].valid) continue;
      
      double currentPrice = isBuy ? 
         SymbolInfoDouble(_Symbol, SYMBOL_ASK) : 
         SymbolInfoDouble(_Symbol, SYMBOL_BID);
      
      if(currentPrice >= g_SDZones[i].bottomPrice && 
         currentPrice <= g_SDZones[i].topPrice) {
         
         if((isBuy && !g_SDZones[i].isSupply) || (!isBuy && g_SDZones[i].isSupply)) {
            confirmations += 12;
            reasons += "Supply/Demand Zone | ";
            atSDZone = true;
            break;
         }
      }
   }
   
   // 13. POI (Point of Interest) Models
   if(CheckPOI_Model1(analysisTF, tradeTF, isBuy)) {
      confirmations += 12;
      reasons += "POI Model 1 | ";
   }
   
   if(CheckPOI_Model2(analysisTF, tradeTF, isBuy)) {
      confirmations += 12;
      reasons += "POI Model 2 | ";
   }
   
   // 14. SMT (Smart Money Tool/Trap)
   if(CheckSMTDivergence(isBuy)) {
      confirmations += 10;
      reasons += "SMT Divergence | ";
   }
   
   // 15. IMPULSE & CORRECTION
   if(UseImpulseCorrection && ArraySize(g_Corrections) > 0) {
      CorrectionWave lastCorrection = g_Corrections[0];
      
      // Look for entries at 50-61.8% retracement
      if(lastCorrection.correctionPercent >= 50 && lastCorrection.correctionPercent <= 61.8) {
         confirmations += 10;
         reasons += "Fib Correction (" + DoubleToString(lastCorrection.correctionPercent, 1) + "%) | ";
      }
   }
   
   // 16. CORRELATED PAIR
   if(UseCorrelation && CorrelatedPair != "") {
      // Check if correlated pair confirms direction
      double corrClose = iClose(CorrelatedPair, analysisTF, 0);
      double corrPrevClose = iClose(CorrelatedPair, analysisTF, 1);
      
      bool corrBullish = (corrClose > corrPrevClose);
      
      if((isBuy && corrBullish) || (!isBuy && !corrBullish)) {
         confirmations += 8;
         reasons += "Correlation Confirmed | ";
      }
   }
   
   // 17. QML PATTERN
   if(DetectQMLPattern(analysisTF, isBuy)) {
      confirmations += 15;
      reasons += "QML Pattern | ";
      hasQML = true;
   }
   
   // 18. DOUBLE TOP/BOTTOM
   if(isBuy && DetectDoubleBottom(analysisTF)) {
      confirmations += 12;
      reasons += "Double Bottom | ";
      hasDoublePattern = true;
   } else if(!isBuy && DetectDoubleTop(analysisTF)) {
      confirmations += 12;
      reasons += "Double Top | ";
      hasDoublePattern = true;
   }
   
   // 19. CHANNEL
   if(UseChannels && ArraySize(g_Channels) > 0) {
      // Check if price is at channel boundary
      for(int i = 0; i < ArraySize(g_Channels); i++) {
         if(!g_Channels[i].valid) continue;
         
         double currentPrice = isBuy ? 
            SymbolInfoDouble(_Symbol, SYMBOL_ASK) : 
            SymbolInfoDouble(_Symbol, SYMBOL_BID);
         
         // Calculate current channel levels
         TrendLine upper = g_Channels[i].upperLine;
         TrendLine lower = g_Channels[i].lowerLine;
         
         double upperSlope = (upper.end_price - upper.start_price) / (upper.end_time - upper.start_time);
         double lowerSlope = (lower.end_price - lower.start_price) / (lower.end_time - lower.start_time);
         
         double currentUpper = upper.end_price + upperSlope * (TimeCurrent() - upper.end_time);
         double currentLower = lower.end_price + lowerSlope * (TimeCurrent() - lower.end_time);
         
         // Buy at lower channel, Sell at upper channel
         if(isBuy && MathAbs(currentPrice - currentLower) < PipsToPrice(5)) {
            confirmations += 10;
            reasons += "Channel Support | ";
            break;
         } else if(!isBuy && MathAbs(currentPrice - currentUpper) < PipsToPrice(5)) {
            confirmations += 10;
            reasons += "Channel Resistance | ";
            break;
         }
      }
   }
   
   // 20. SYMMETRIC TRIANGLE
   if(hasTriangle) {
      confirmations += 8;
      reasons += "Symmetric Triangle | ";
   }
   
   // 21. FIBONACCI LEVELS
   if(UseFibonacci && ArraySize(g_SwingHighs) > 0 && ArraySize(g_SwingLows) > 0) {
      double recentHigh = g_SwingHighs[0].price;
      double recentLow = g_SwingLows[0].price;
      
      double fibPrice = isBuy
                  ? SymbolInfoDouble(_Symbol, SYMBOL_ASK)
                  : SymbolInfoDouble(_Symbol, SYMBOL_BID);

      if(IsAtFibLevel(fibPrice, recentHigh, recentLow)) {
         confirmations += 10;
         reasons += "Fib Level | ";
      }
 
      // 22. SNIPER ENTRY
      if(SniperEntryCheck(tradeTF, isBuy)) {
         confirmations += 12;
         reasons += "Sniper Entry | ";
      }
      
      
      // 23. LIQUIDITY SWIPE
      if(DetectLiquiditySwipe(tradeTF, isBuy)) {
         confirmations += 10;
         reasons += "Liquidity Swipe | ";
      }
      
      // 24. SESSION LIQUIDITY
      if(UseSessionLiquidity) {
         for(int i = 0; i < ArraySize(g_SessionData); i++) {
            double currentPrice = isBuy ? 
               SymbolInfoDouble(_Symbol, SYMBOL_ASK) : 
               SymbolInfoDouble(_Symbol, SYMBOL_BID);
            
            if(isBuy && !g_SessionData[i].lowSwept && 
               currentPrice <= g_SessionData[i].sessionLow + PipsToPrice(5)) {
               confirmations += 8;
               reasons += "Session Low Sweep | ";
               g_SessionData[i].lowSwept = true;
               break;
            } else if(!isBuy && !g_SessionData[i].highSwept && 
                      currentPrice >= g_SessionData[i].sessionHigh - PipsToPrice(5)) {
               confirmations += 8;
               reasons += "Session High Sweep | ";
               g_SessionData[i].highSwept = true;
               break;
            }
         }
      }
      
      // 25. ORDER FLOW
      if(UseOrderFlow) {
         if((isBuy && g_OrderFlow.bullishFlow) || (!isBuy && !g_OrderFlow.bullishFlow)) {
            confirmations += (int)(MathAbs(g_OrderFlow.imbalance) / 2);
            reasons += "Order Flow (" + DoubleToString(g_OrderFlow.imbalance, 1) + "%) | ";
         }
      }
      
      // 26. REVERSAL CANDLES
      if(isBuy && IsBullishReversalCandle(tradeTF)) {
         confirmations += 10;
         reasons += "Bullish Reversal | ";
         } 
      else if(!isBuy && IsBearishReversalCandle(tradeTF)) {
      confirmations += 10;
      reasons += "Bearish Reversal | ";
   }
   
   // 27. IFC (Institutional Funding Candle)
   if(UseIFC && ArraySize(g_IFCs) > 0) {
      InstitutionalCandle lastIFC = g_IFCs[0];
      
      if((isBuy && lastIFC.isBullish) || (!isBuy && !lastIFC.isBullish)) {
         confirmations += 12;
         reasons += "IFC Confirmed | ";
      }
   }
   
   // ========== TRADING HUB JUKA BONUS ==========
   if(UseTradingHubJuka && g_JukaAnalysis.readyForEntry) {
      confirmations += (int)(g_JukaAnalysis.trendStrength / 5);
      reasons += "Juka Method (" + g_JukaAnalysis.setupQuality + ") | ";
   }
   
   // ========== VOLATILITY & FILTERS ==========
   if(!CheckVolatilityFilter(analysisTF)) {
      Print("‚ùå Volatility Filter Failed");
      return signal;
   }
   
   if(!IsWithinTradingHours()) {
      Print("‚ùå Outside Trading Hours");
      return signal;
   }
   
   if(!IsValidSession()) {
      Print("‚ùå Invalid Session");
      return signal;
   }
   
   // ========== MINIMUM CONFIDENCE CHECK ==========
   int minConfidence = 45;
   if(UseTradingHubJuka && Juka_RequireAlignment) {
      minConfidence = 55; // Higher standard with Juka
   }
   
   if(confirmations < minConfidence) {
      Print("‚ö†Ô∏è Low Confidence: ", confirmations, "% (Min: ", minConfidence, "%)");
      return signal;
   }
   
   // ========== CALCULATE ENTRY PARAMETERS ==========
   double currentPrice = isBuy ? 
      SymbolInfoDouble(_Symbol, SYMBOL_ASK) : 
      SymbolInfoDouble(_Symbol, SYMBOL_BID);
   
   signal.entryPrice = currentPrice;
   
   // Smart Stop Loss Placement
   double slDistance = 0;
   
   if(isBuy) {
      double nearestLow = 999999;
      
      // Use swing low
      if(ArraySize(g_SwingLows) > 0) {
         nearestLow = g_SwingLows[0].price;
      }
      
      // Use order block low if closer
      if(atOB) {
         for(int i = 0; i < ArraySize(g_OrderBlocks); i++) {
            if(g_OrderBlocks[i].valid && g_OrderBlocks[i].isBullish) {
               nearestLow = MathMin(nearestLow, g_OrderBlocks[i].lowPrice);
               break;
            }
         }
      }
      
      // Use demand zone if present
      if(atSDZone) {
         for(int i = 0; i < ArraySize(g_SDZones); i++) {
            if(g_SDZones[i].valid && !g_SDZones[i].isSupply) {
               nearestLow = MathMin(nearestLow, g_SDZones[i].bottomPrice);
               break;
            }
         }
      }
      
      if(nearestLow < 999999) {
         slDistance = signal.entryPrice - nearestLow - PipsToPrice(5);
      }
   } else {
      double nearestHigh = 0;
      
      // Use swing high
      if(ArraySize(g_SwingHighs) > 0) {
         nearestHigh = g_SwingHighs[0].price;
      }
      
      // Use order block high if closer
      if(atOB) {
         for(int i = 0; i < ArraySize(g_OrderBlocks); i++) {
            if(g_OrderBlocks[i].valid && !g_OrderBlocks[i].isBullish) {
               nearestHigh = MathMax(nearestHigh, g_OrderBlocks[i].highPrice);
               break;
            }
         }
      }
      
      // Use supply zone if present
      if(atSDZone) {
         for(int i = 0; i < ArraySize(g_SDZones); i++) {
            if(g_SDZones[i].valid && g_SDZones[i].isSupply) {
               nearestHigh = MathMax(nearestHigh, g_SDZones[i].topPrice);
               break;
            }
         }
      }
      
      if(nearestHigh > 0) {
         slDistance = nearestHigh - signal.entryPrice + PipsToPrice(5);
      }
   }
   
   // Validate SL
   double minSL = PipsToPrice(DefaultSLPips * 0.5);
   double maxSL = PipsToPrice(DefaultSLPips * 2);
   
   if(slDistance < minSL || slDistance > maxSL || slDistance == 0) {
      slDistance = PipsToPrice(DefaultSLPips);
   }
   
   signal.stopLoss = isBuy ? 
      signal.entryPrice - slDistance : 
      signal.entryPrice + slDistance;
   
   // Calculate TP
   signal.takeProfit = isBuy ? 
      signal.entryPrice + (slDistance * DefaultRR) : 
      signal.entryPrice - (slDistance * DefaultRR);
   
   signal.confidence = confirmations;
   signal.reason = reasons;
   signal.valid = true;
   
   // ========== FINAL SIGNAL REPORT ==========
   Print("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
   Print("‚ïë     ‚úÖ VALID TRADE SIGNAL GENERATED       ‚ïë");
   Print("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
   Print("Direction: ", (isBuy ? "üü¢ BUY" : "üî¥ SELL"));
   Print("Entry: ", signal.entryPrice);
   Print("SL: ", signal.stopLoss, " (", DoubleToString(PriceToPips(slDistance), 1), " pips)");
   Print("TP: ", signal.takeProfit, " (R:", DefaultRR, ")");
   Print("Confidence: ", confirmations, "%");
   Print("TF Alignment: ", signal.timeframeAlignment);
   Print("Concepts Used: ", reasons);
   Print("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
   
   return signal;
}

//==================== ENHANCED ONTICK WITH ALL CONCEPTS =============
void OnTick() {
   ResetDailyStats();
   UpdateDailyStats();

   if(!TradingEnabled) return;
   if(!CheckRiskLimits()) return;

   ManageOpenTrades();

   if(PositionSelect(_Symbol)) return;
   if((TimeCurrent() - g_LastTradeTime) < 120) return;

   static datetime lastAnalysis = 0;
   if(TimeCurrent() - lastAnalysis >= 3600) {
      CalculateDailyBias();
      if(UseTradingHubJuka) {
         AnalyzeWithTradingHubJuka();
      }
      lastAnalysis = TimeCurrent();
   }

   TradeSignal signal;

   if(TradeOnM1 && IsNewBar(PERIOD_M1)) {
      signal = GenerateEnhancedSignal(AnalysisTF1, TradeTF1);
      if(signal.valid && signal.confidence >= 50) {
         if(ExecuteTrade(signal)) return;
      }
   }

   if(IsNewBar(PERIOD_M5)) {
      signal = GenerateEnhancedSignal(AnalysisTF2, TradeTF2);
      if(signal.valid && signal.confidence >= 55) {
         if(ExecuteTrade(signal)) return;
      }
   }

   if(IsNewBar(PERIOD_M15)) {
      signal = GenerateEnhancedSignal(AnalysisTF3, TradeTF3);
      if(signal.valid && signal.confidence >= 60) {
         if(ExecuteTrade(signal)) return;
      }
   }

   if(IsNewBar(PERIOD_H1)) {
      signal = GenerateEnhancedSignal(AnalysisTF4, TradeTF4);
      if(signal.valid && signal.confidence >= 65) {
         if(ExecuteTrade(signal)) return;
      }
   }

   if(IsNewBar(PERIOD_H4)) {
      signal = GenerateEnhancedSignal(AnalysisTF5, TradeTF5);
      if(signal.valid && signal.confidence >= 70) {
         if(ExecuteTrade(signal)) return;
      }
   }
}
